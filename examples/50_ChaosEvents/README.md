# Events

This example demonstrates how to use **events** inside CHAOS to trigger task behavior without relying on periodic task activation.  
Instead of scheduling a task at a slow rate, the system uses:

- A **1 ms periodic task** that continuously checks for an event.
- A **1 s one-shot (or periodic) alarm** whose callback **sets an event**.
- The task reacts only when the event is raised, making it extremely responsive yet efficient.

This pattern shows how CHAOS decouples *event generation* from *event handling*, allowing asynchronous behavior without adding polling delays or long scheduling intervals.

---

### What this example does

- A fast task runs every **1 ms**.  
  It checks whether a **blink event** has been raised.
- A CHAOS **alarm**, configured to fire every **1 s**, triggers its callback.
- Inside the callback, the alarm **generates (signals) the event**.
- On the next 1 ms task activation, the task sees the event and performs the blink action (typically toggling an LED or printing status).
- After handling the event, the task clears it and continues running.

The result:  
A 1 ms task reacts to a 1 s asynchronous signal with minimal latency and without blocking.

---

### Why this example matters

This example highlights several important CHAOS features:

#### **1. Decoupled timing**
The event occurs at a *slow* 1 s rhythm, but the handler runs within the *fast* 1 ms task.  
No need to schedule the blink task at 1 s — it can remain high-frequency and responsive.

#### **2. Efficient event-driven design**
The task does not waste CPU cycles in long loops or delays.  
It simply checks for an event bit and continues.

#### **3. Alarm-driven event signaling**
Alarms are an elegant way to produce asynchronous triggers:
- They run outside the task context.
- They can set events, update state, or schedule new tasks.
- They keep user logic clean and deterministic.

#### **4. Typical embedded use-case**
This pattern resembles:
- Sensor sampling at high rate + slow threshold triggers  
- Low-power wakeup events  
- LED/UI blinking generated by timers  
- Communication state machines reacting to periodic triggers  

---

### What you’ll see when it runs

- The 1 ms task logs activity or maintains a counter.
- Every 1 s, the alarm’s callback sets the blink event.
- On the next scheduler run (within 1 ms), the event handler toggles the LED or prints a “blink” message.
- The system keeps running indefinitely, showing clean separation between *event generation* (alarm) and *event processing* (task).

---

### How to use this example

1. Build and flash it on your target board.
2. Open your serial terminal (or monitor LEDs).
3. Observe:
   - The fast task running at stable 1 ms intervals.
   - A blink action occurring exactly every 1 s, driven purely by event signaling.

Feel free to modify:
- The alarm interval
- The event handler logic
- The task frequency  
to explore how CHAOS events behave under different timing loads.

---

### Summary

`50_ChaosEvents` is a compact demonstration of how CHAOS enables **responsive, event-driven programming** using:
- High-frequency tasks
- Low-frequency alarm callbacks
- Lightweight event signaling  

It shows how to integrate periodic signals into fast-running logic without blocking, busy-waiting, or complicating task scheduling.
